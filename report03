가) 디자인 패턴 정리

== 생성 패턴 ==
객체 인스턴스를 생성하는 패턴으로, 클라이언트와 그 클라이언트가 생성해야 하는 객체 인스턴스 사이의 연결을 끊어 주는 패턴

- 싱글턴 패턴 : 특정 클래스에 객체 인스턴스가 하나만 만들어지도록 해주는 패턴 
- 추상 팩토리 패턴 : 구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 이루어진 제품군을 생산하는 인터페이스를 제공
- 팩토리 메소드 패턴 : 객체를 생성할 때 필요한 인터페이스를 만듦


== 행동 패턴 ==
클래스와 객체들이 상호작용하는 방법과 역할을 분담하는 방법을 다루는 패턴

- 템플릿 메소드 패턴 : 알고리즘의 골격을 정의. 알고리즘의 구조는 그대로 유지하면서 알고리즘의 특정 단계를 서브클래스에서 재정의
- 상태 패턴 : 객체의 내부 상태가 바뀜에 따라서 객체의 행동을 바꿀 수 있도록 돕는 패턴 
- 반복자 패턴 : 컬렉션의 구현 방법을 노출하지 않으면서 집합체 내의 모든 항목에 접근하는 방법을 제공
- 전략 패턴 : 알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 함
- 옵저버 패턴 : 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의


== 구조 패턴 ==
클래스와 객체를 더 큰 구조로 만들 수 있게 구상을 사용하는 패턴

- 데코레이터 패턴 : 객체에 추가 요소를 동적으로 더할 수 있는 패턴
 - 프록시 패턴 : 특정 객체로의 접근을 제어하는 대리인(특정 객체를 대변하는 객체)을 제공
- 컴포지트 패턴 : 컴포지트 패턴으로 객체를 트리구조로 구성해서 부분-전체 계층구조를 구현
- 어댑터 패턴 : 특정 틀래스 인터페이스를 클라이언트에서 요구하는 다른 인터페이스로 변환
- 퍼사드 패턴 : 서브시스템에 있는 일련의 인터페이스를 통합 인터페이스로 묶음



나) 스프링에서 사용하는 디자인 패턴

<<싱글턴 패턴>>  (생성 패턴)
최초 한번만 메모리를 할당하고 그 메모리에 인스턴스를 만들어 사용하는 디자인 패턴으로 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고, 최초 생성 이후에 호출된 생성자는 생성한 객체를 반환

스프링에서는 클래스 자체에 의해서 생성하지 않고, 스프링 컨테이너에 의해 구현되기 때문에 컨테이너 내에서 특정 클래스에 대해 @Bean이 정의되면, 스프링 컨테이너는 그 클래스에 대해 하나의 인스턴스를 만듦. 이 공유 인스턴스는 설정 정보에 의해 관리되고, bean이 호출될 때마다 스프링은 생성된 공유 인스턴스를 반환
=> @Bean의 존재 유무에 따른 변화?

<<템플릿 메소드 패턴>> (행동패턴)
슈퍼클래스에 기본적인 로직의 흐름을 작성하고, 일부 변경이 필요한 부분은 서브클래스에서 추상메소드로 오버라이딩하여 사용할 수 있는 형태로 서브클래스에서 필요에 맞게 이를 구현하여 사용하는 디자인 패턴으로 서로 다른 유사한 컴포넌트가 있을 때, 구성요소의 대부분을 동일하게 하고 일부만 다르게 하여 중복을 최소화할 때 사용

ex)
@Configuration
public class WebConfig implements WebMvcConfigurer {
 
@Override
public void addViewControllers(ViewControllerRegistry registry ) {

   registry.addRedirectViewController("/", "home");

} 



다) 디자인 패턴을 설계할 시 준수해야 할 규칙

1. 디자인 패턴 설계 문제를 해결하는 방법을 고려
2. 디자인 패턴의 존재 의도를 고려
3. 디자인 패턴들이 상호 연관되는 방식을 연구
4. 비슷한 목적을 가진 설계 패턴들을 연구
5. 재설계가 발생되는 원인 살펴보기
6. 설계에서 가변적이어야 하는 사항들을 살펴보기

